# ATIO KB Mobile — Architecture & Data Synchronization

This document explains how the **ATIO KB Mobile** workspace is integrated today, why it currently ships with an embedded database, and how it can evolve to **stay synchronized with the authoritative ATIO KB over time** (including a future “real-time”/near-real-time integration).

---

## Goals and constraints

- **Primary product goal**: Provide a mobile experience for exploring ATIO KB innovations (browse, filter, drill-down, view details). Core browsing works without network access because the KB data is bundled with the app at build time. **Note**: AI features (search, summaries, bullet points) require internet connectivity.
- **Search goal**: Support “describe a problem” style search with higher relevance than basic keyword search.
- **Constraint today**: The ATIO KB website/database is behind authentication and the API cannot be opened publicly, so the mobile app cannot query the KB directly in production.
- **Design choice today**: Package the knowledge base as a **local SQLite database** bundled with the app, so browsing is instant and works without network access (because data is bundled, not because users can "load" content offline).
- **Future assumption**: A secure application backend will be allowed to read from ATIO KB in real time (or via a change feed), and mobile clients can sync without direct DB access.

---

## System overview (today)

The workspace is a **two-process** system in development:

1. **Mobile app (Expo React Native)** — browsing from bundled data + UI.
2. **Backend API (Express)** — AI-assisted search and summarization; reads from the same SQLite dataset schema.

### Data stores

- **Bundled KB snapshot**: `assets/db/atiokb.db`
  - Copied into app storage on first run by `src/database/db.js` and opened with `expo-sqlite`.
  - Used for almost all screens: stats, browse, filters, drill-down lists, and innovation detail content.
- **Local user state**:
  - `AsyncStorage` for bookmarks, “downloads” list, and local “liked” IDs.
  - Auxiliary SQLite tables (created at runtime) for anonymous aggregate feedback and cached AI summaries:
    - `innovation_thumbs_up_counts`
    - `innovation_comments`
    - `innovation_bullet_cache`
  - These tables are **separate from the KB content** and do not modify the KB snapshot records.

### Backend API responsibilities (today)

The backend is explicitly **not** the KB source-of-truth. It is a helper service that:

- **Search**: `POST /api/search`
  - Stage 1: candidate retrieval via SQLite FTS (fast lexical search)
  - Stage 2: optional LLM rerank (OpenAI) using *sanitized* long-text descriptions only (no metadata such as countries, types, SDGs, etc.)
- **Transcription**: `POST /api/transcribe` (Whisper)
- **Description bullets**: `POST /api/summarize-bullets`
  - Receives only the long-text description field; no metadata is sent to the AI

The backend opens a **read-only copy** of `assets/db/atiokb.db` on startup (`backend/server.js`) to guarantee the asset is never modified.

### Client ↔ backend integration

- The app targets the backend via `src/config/api.js`:
  - Physical device uses the Metro host (LAN IP)
  - iOS simulator uses `localhost`
  - Android emulator uses `10.0.2.2`
- This makes the app **already “API-ready”** for endpoints that exist today (search/transcribe/summarize).
- However, **core KB browsing does not use the backend** today; it reads SQLite directly for speed (data is bundled with the app).

---

## Data flow (today)

### “Explore / Browse” path (bundled data)

1. App starts → `initDatabase()` copies `assets/db/atiokb.db` into the app’s SQLite folder if needed.
2. Screens call read functions in `src/database/db.js` (e.g. `getStats`, `searchInnovations`, `getInnovationById`).
3. UI renders immediately from local queries; no network required because data is bundled with the app.

### “AI Search” path (online, best-effort)

1. User enters a natural-language query on Home.
2. App calls backend `POST /api/search` via `aiSearch()` in `src/config/api.js`.
3. Backend retrieves candidates from SQLite FTS and optionally reranks with an LLM.
4. **Privacy note**: Only descriptions are sent to the LLM for reranking; no metadata (countries, types, SDGs, etc.) is included.
5. App renders results; if the backend is unreachable, the UI shows an error and continues to support browsing from bundled data.

### “AI bullets in detail drawer” (online with local cache)

1. When the user opens a solution’s drawer, the client sends **only the description** to `POST /api/summarize-bullets`.
2. **Privacy note**: No metadata (countries, types, SDGs, cost, complexity, etc.) is sent to the AI—only the description text.
3. The result is cached in the local SQLite table `innovation_bullet_cache` keyed by `innovation_id`.
4. Subsequent opens for the same innovation use the cache and avoid repeated AI calls.

### "Downloads" path (offline viewing)

1. User downloads an innovation from Home or Explore screens (saves innovation data to AsyncStorage).
2. Downloaded innovations are stored locally in `AsyncStorage` under the `completedDownloads` key.
3. Users can view downloaded innovations offline in the Downloads screen, including full detail views via the DetailDrawer. Users can also save downloads to files and share to others.
4. Downloaded innovations persist across app restarts and work without network access.

### Network requirements summary

**Works offline (no internet required)**:
- Browsing bundled innovation data (Explore, filters, detail views)
- Viewing downloaded innovations in the Downloads section
- Bookmarks and local user state

**Requires internet**:
- AI search (`POST /api/search`)
- AI bullet summaries (`POST /api/summarize-bullets`)
- AI summary for comparison (OpenAI API, used in Bookmarks comparison view)
- Voice transcription (`POST /api/transcribe`)

---

## Why the KB is bundled as SQLite today

Because the ATIO KB is not currently accessible via an open API, the mobile app cannot rely on live requests to the KB. The repository therefore treats `atiokb.db` as a **versioned snapshot artifact** generated outside the app at build time.

In practical terms, the current pipeline is:

- **Prepare normalized KB exports** (e.g., JSON files)
- **Load into a relational database** (SQL) for validation/consistency and easier transformation
- **Build a mobile-optimized SQLite snapshot** (`atiokb.db`) that matches the schema expected by `src/database/db.js`
- **Bundle** that SQLite file into the mobile app as an asset

This approach yields:

- **Core browsing works without network** (data is bundled with the app at build time)
- **Fast UX** (local queries, no waiting on network)
- **Reproducible releases** (the app ships with a known dataset version)

**Offline capabilities**:
- **Bundled data browsing**: All innovation content (browse, filters, detail views) works offline because data is bundled with the app
- **Downloads**: Users can download innovations to view them offline in the Downloads section. Downloaded innovations are stored locally and can be viewed without network access
- **AI features require internet**: AI search, AI summaries, and bullet points require backend connectivity


---

## How the App Stays Aligned with the KB Data Model

This section explains how the app maintains alignment with the ATIO KB data model, both today (using bundled snapshots) and in the future (when real-time API access becomes available).

### Current State: Bundled Snapshot Approach

**Today**, because the ATIO KB website is behind authentication and its API cannot be opened publicly, the app uses a **bundled SQLite snapshot** approach:

1. **Data preparation** (outside the app repository):
   - KB data is exported from the ATIO source as JSON files
   - JSON records are transformed and loaded into a SQLite database (`atiokb.db`)
   - A mobile-optimized SQLite snapshot is built that matches the schema expected by `src/database/db.js`
   - The SQLite file is bundled with the app as an asset

2. **Runtime behavior**:
   - On first launch, the app copies the bundled DB from assets into app storage
   - All innovation reads go through `src/database/db.js`, which queries local SQLite
   - Data is fixed at build time—updates to the ATIO website do not propagate until a new DB is generated and a new app build is released

3. **Keeping data fresh (current model)**:
   - Re-run the ETL/import process with updated JSON from the ATIO source
   - Replace `assets/db/atiokb.db` with the new SQLite file
   - Rebuild and redeploy the app (or ship an OTA update if using Expo Updates with asset changes)

### Future: Real-Time Synchronization with ATIO KB

**In the future**, when a secure application backend is allowed to read from ATIO KB in real time, the app will evolve to support synchronization while preserving the ability to work without network (via bundled or cached data).

#### Design Principles

- **Treat ATIO KB as the source of truth**
- **Local-first + server-driven freshness**: Read from local SQLite immediately (fast UI), synchronize in the background when connectivity exists
- **Resolve updates deterministically** via server-assigned versions/timestamps
- **Keep mobile device as a cached replica** (SQLite), updated incrementally

#### Proposed Synchronization Strategies

The backend should provide **one of these patterns** (from simplest to most real-time):

**Option A — Versioned snapshots** (simplest, high confidence):
- Endpoints: `GET /kb/version` → `{ version, publishedAt, checksum, sizeBytes }`, `GET /kb/snapshot.sqlite` → downloads latest snapshot
- Client behavior: On app launch, compare local `kb_version` to `/kb/version`; if newer exists, download snapshot in background and replace atomically
- Pros: Very simple and reliable; works even if upstream KB cannot expose per-record change feeds
- Cons: Larger downloads when KB changes

**Option B — Incremental delta sync** (preferred medium-term):
- Endpoints: `GET /kb/changes?since=<cursor>&limit=...` → `{ nextCursor, changes: [...] }` (upserts/deletes with `updated_at` and stable IDs)
- Client behavior: Store local `sync_cursor` and `kb_version`; apply changes in a single SQLite transaction (upsert/delete, rebuild FTS indices)
- Pros: Small network usage; near-real-time feasible; can update without replacing full DB
- Cons: More backend + client complexity; must guarantee schema compatibility and correct FTS maintenance

**Option C — Streaming updates** (real-time):
- Use WebSockets/SSE or push notifications: `GET /kb/stream` → emits change events, or push notification triggers background fetch
- Pros: Lowest latency; "real-time" feel
- Cons: Most operational complexity; mobile background limitations apply

**Note**: Even with a real-time upstream database, mobile clients are constrained by intermittent connectivity, background execution limits, and battery/data usage constraints. The practical target is **near-real-time**: sync on app open, periodic background fetch where permitted, and push-triggered refresh for important updates.

#### Backend Integration Approach

To move from "bundled snapshot" to "live KB integration", the recommended approach is **not** to connect mobile clients directly to the ATIO KB database. Instead:

- Introduce an **authenticated application backend** (or expand the existing Express backend) that:
  - connects to ATIO KB over private networking or trusted credentials
  - exposes a public/mobile-safe API (rate-limited, authenticated, audited)
  - produces a mobile-optimized replication format (snapshot + optional deltas)

This architecture keeps:
- ATIO KB protected behind authentication
- mobile clients simple and secure
- local-first UX intact (bundled or cached data)

**Security considerations**:
- Authentication (OAuth/JWT, device tokens, or signed URLs for snapshot downloads)
- Request throttling
- Careful PII/content controls: AI endpoints only receive long-text descriptions; no metadata (countries, types, SDGs, etc.) is sent to LLMs

#### API Readiness: What's Already in Place

The app is **structurally prepared** for API connectivity:

| Capability | Status |
|------------|--------|
| **Centralized API config** | `src/config/api.js` — `SEARCH_API_URL`, `aiSearch`, `transcribeAudio` |
| **Modular API calls** | `aiSearch` and `transcribeAudio` are standalone; easy to extend |
| **Single data abstraction** | `db.js` is the sole reader of innovation data; screens depend on it, not on SQLite directly |
| **Backend stateless design** | Backend can be deployed separately and pointed at any DB or API |
| **Stable schema** | `innovations` and related tables have a consistent structure |
| **HTTP integration layer** | Already uses HTTP successfully for AI search, transcription, summarization |

#### Gaps for Remote API

| Gap | Description |
|-----|-------------|
| **No configurable API base URL** | `SEARCH_API_URL` is derived from Metro host (localhost, 10.0.2.2, or device IP). No `EXPO_PUBLIC_API_URL` for staging/production. |
| **No authentication** | No tokens, API keys, or headers for authenticated ATIO KB APIs. |
| **No KB sync mechanism** | No built-in mechanism to check KB version from remote source, download new snapshot/delta, or swap/update local DB while app is running. |
| **No offline/online handling** | No fallback when backend is unreachable; no retry or cached responses for core data. |
| **Mixed data sources** | Explore uses local DB; Search uses backend. No unified abstraction that can switch between local and remote. |

#### Recommended Path to API Readiness

To fully support real-time ATIO KB data, the main work is:

1. **Add `EXPO_PUBLIC_API_URL`** — Allow overriding the API base URL via environment variable for production.
2. **Introduce a data source abstraction** — Create a `DataService` (or similar) that implements the same interface as `db.js` but can fetch from an API. Use dependency injection or context to switch between local SQLite and remote API.
3. **Add auth support** — Extend `api.js` to attach auth headers (e.g., Bearer token) when `EXPO_PUBLIC_API_TOKEN` is set.
4. **Implement KB sync layer** — Add a module like `src/services/kbSync.js` that:
   - Stores metadata locally (`kb_version`, `sync_cursor`, `last_sync_at`)
   - Coordinates downloads (uses `expo-file-system`, verifies integrity)
   - Applies updates safely (atomic file swap for snapshots, transactional upsert/delete for deltas)
5. **Implement offline fallback** — When API calls fail, fall back to local SQLite if available.
6. **Optional: Background sync** — If using local SQLite as cache, add a sync job that periodically fetches updates from the API and merges into the local DB.

#### Operational Model for Staying Synchronized

To keep the app "in sync" without sacrificing UX:

- **On app launch / foreground**: Check `/kb/version`; if new, download and update in background
- **Periodic background refresh** (platform-permitting): Daily/weekly version check
- **On-demand refresh**: Settings screen action: "Check for updates"
- **Release strategy**:
  - For major schema changes: Ship a new app build with a new base snapshot and migration logic
  - For content-only updates: Sync via snapshot/deltas without requiring a new binary

The rest of the app can remain largely unchanged because it already depends on `src/database/db.js` as the single data access boundary.

---

In the future, you want the app to remain synchronized with the ATIO KB “over time” while preserving the ability to work without network (via bundled or cached data). The recommended model is:

- Treat ATIO KB as the **source of truth**
- Introduce a secure **sync API** (or an internal integration service) that exposes KB changes safely
- Keep the mobile device as a **cached replica** (SQLite), updated incrementally

### Key design principle: local-first + server-driven freshness

The app should always be able to:

- Read from local SQLite immediately (fast UI)
- Synchronize in the background when connectivity exists
- Resolve updates deterministically via server-assigned versions/timestamps

### Proposed “KB Sync API” shape

To support robust synchronization, the backend should provide **one of these patterns** (from simplest to most real-time):

#### Option A — Versioned snapshots (simplest, high confidence)

Provide endpoints such as:

- `GET /kb/version` → `{ version, publishedAt, checksum, sizeBytes }`
- `GET /kb/snapshot.sqlite` → downloads the latest SQLite snapshot (or a compressed file)

Client behavior:

- On app launch (or daily), compare local `kb_version` to `/kb/version`
- If newer exists, download snapshot in background
- Replace local KB database **atomically** (download → verify checksum → swap file)

Pros:

- Very simple and reliable; easiest to ship first
- Works even if upstream KB cannot expose per-record change feeds

Cons:

- Larger downloads when KB changes

#### Option B — Incremental delta sync (preferred medium-term)

Expose a deterministic change log:

- `GET /kb/changes?since=<cursor>&limit=...` → `{ nextCursor, changes: [...] }`
  - changes are upserts/deletes across the innovation tables
  - include `updated_at` and stable IDs
- `GET /kb/version` as above

Client behavior:

- Store a local `sync_cursor` and `kb_version`
- Apply changes in a single SQLite transaction:
  - Upsert changed rows
  - Remove deleted rows
  - Rebuild/refresh FTS indices as needed

Pros:

- Small network usage; near-real-time feasible
- Can update without replacing the full DB

Cons:

- More backend + client complexity
- Must guarantee schema compatibility and correct FTS maintenance

#### Option C — Streaming updates (real-time)

Use WebSockets/SSE (or push notifications to trigger background fetch):

- `GET /kb/stream` → emits change events
- Or push notification: “KB updated” → app wakes and calls `/kb/changes`

Pros:

- Lowest latency; “real-time” feel

Cons:

- Most operational complexity; mobile background limitations apply

### What “real-time” means on mobile

Even with a real-time upstream database, mobile clients are constrained by:

- intermittent connectivity
- background execution limits (iOS/Android)
- battery/data usage constraints

So the practical target is **near-real-time**: e.g. sync on app open, periodic background fetch where permitted, and push-triggered refresh for important updates.

---

## How the current codebase is positioned for future sync

### What is already “API-ready”

- The app already has an HTTP integration layer (`src/config/api.js`) and uses it successfully for:
  - AI search (`/api/search`)
  - transcription (`/api/transcribe`)
  - summarization (`/api/summarize-bullets`)
- This means moving from `http://<dev-host>:3001` to a deployed URL is straightforward once you have a hosted backend.

### What is currently “snapshot-based”

- The core KB browsing experience reads from local SQLite (`src/database/db.js`) and assumes the schema is present locally.
- There is no built-in mechanism yet to:
  - check KB version from a remote source
  - download a new snapshot/delta
  - swap/update the local DB while the app is running

### Recommended minimal additions (to enable sync)

Add a small, explicit “KB sync” layer (conceptually, a new module like `src/services/kbSync.js`) that:

- **Stores metadata** locally:
  - `kb_version` (string or integer)
  - `sync_cursor` (for delta sync)
  - `last_sync_at`
- **Coordinates downloads**:
  - uses `expo-file-system` to download new snapshot/deltas
  - verifies integrity (checksum)
- **Applies updates safely**:
  - snapshot: atomic file swap, then reopen DB
  - delta: transactional upsert/delete, then FTS maintenance

The rest of the app can remain largely unchanged because it already depends on `src/database/db.js` as the single data access boundary.

---

## Backend integration approach (future)

To move from “bundled snapshot” to “live KB integration”, the recommended approach is **not** to connect mobile clients directly to the ATIO KB database. Instead:

- Introduce an **authenticated application backend** (or expand the existing Express backend) that:
  - connects to ATIO KB over private networking or trusted credentials
  - exposes a public/mobile-safe API (rate-limited, authenticated, audited)
  - produces a mobile-optimized replication format (snapshot + optional deltas)

This architecture keeps:

- ATIO KB protected behind authentication
- mobile clients simple and secure
- local-first UX intact (bundled or cached data)

### Security notes

- The existing backend endpoints are unauthenticated (dev-friendly). For production sync you will likely need:
  - authentication (OAuth/JWT, device tokens, or signed URLs for snapshot downloads)
  - request throttling
  - careful PII/content controls: AI endpoints only receive long-text descriptions; no metadata (countries, types, SDGs, etc.) is sent to LLMs

---

## Operational model for staying synchronized over time

To keep the app “in sync” without sacrificing UX, adopt the following cadence:

- **On app launch / foreground**:
  - check `/kb/version`
  - if new: download and update in background
- **Periodic background refresh** (platform-permitting):
  - daily/weekly version check
- **On-demand refresh**:
  - Settings screen action: “Check for updates”
- **Release strategy**:
  - for major schema changes: ship a new app build with a new base snapshot and migration logic
  - for content-only updates: sync via snapshot/deltas without requiring a new binary

---

## Summary

- Today, ATIO KB Mobile's **core browsing** works without network access because the KB content is a **bundled SQLite snapshot** (`assets/db/atiokb.db`) accessed directly by the app. **Downloads** allows users to save innovations locally and view them offline in the Downloads section. **AI features** (search, summaries, bullet points) require internet connectivity.
- The backend provides **AI-enhanced search** and helper endpoints while reading the same SQLite schema in read-only mode.
- The codebase is already set up to talk to an HTTP API for search/transcription/summarization, but it does **not yet** implement KB content syncing.
- The recommended future integration is a secure **KB Sync API** that supports versioned snapshots first (fastest path), then deltas/streaming for near-real-time updates—while keeping local SQLite as the on-device cache for speed and network-independent access.

# ATIO-KB-MOBILE Architecture

## Overview

ATIO-KB-MOBILE is an Expo React Native app that surfaces the ATIO (Agricultural Technology and Innovation Outlook) knowledge base to mobile users. Because the ATIO website is behind authentication and its API cannot be exposed publicly, the current approach uses a **static SQLite snapshot** of the KB data bundled with the app. This document describes the integration approach, data flow, synchronization model, and readiness for future real-time API connectivity.

---

## 1. Current Integration Approach

### 1.1 Data Pipeline (JSON → SQLite)

The ATIO KB content originates from the authenticated website. The integration pipeline is:

1. **Extract** — KB data is exported from the ATIO source (e.g., as JSON or via internal export tools).
2. **Transform & Load** — JSON records are transformed and loaded into a SQLite database (`atiokb.db`). This step is performed **outside** this repository (e.g., via custom ETL scripts or one-off imports).
3. **Bundle** — The resulting `atiokb.db` (~37MB) is placed in `assets/db/` and bundled with the app via Metro (`assetExts: ['db']`).
4. **Runtime** — On first launch, the app copies the bundled DB from assets into app storage (`documentDirectory/SQLite/atiokb.db`) so SQLite can open it. All innovation reads go through this local file.

**Why this approach?** The ATIO website is behind authentication and its API cannot be opened to the public. Preparing JSON and uploading it to SQLite provides a controlled snapshot that can be bundled with the app, allowing the app to work without network access for core content (because data is bundled, not because users can "load" content offline).

### 1.2 Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ATIO KB (authenticated website)                       │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │ Extract (JSON)
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ETL / Import (outside this repo)                          │
│                    JSON → SQLite (atiokb.db)                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │ Bundle
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         assets/db/atiokb.db                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                    │                                    │
                    │ Mobile app                         │ Backend (Node.js)
                    ▼                                    ▼
┌──────────────────────────────────┐    ┌──────────────────────────────────────┐
│  Copy to app storage on 1st run  │    │  Copy to temp dir on startup          │
│  expo-sqlite (read-only)         │    │  better-sqlite3 (read-only)           │
│  src/database/db.js               │    │  backend/server.js                    │
│  • Explore, filters, detail      │    │  • AI search (FTS + LLM rerank)       │
│  • Thumbs up, comments (local)   │    │  • Whisper transcription             │
│  • Bullet summaries (cached)     │    │  • Bullet summaries                  │
└──────────────────────────────────┘    └──────────────────────────────────────┘
                    │                                    │
                    │                                    │ POST /api/search
                    │                                    │ POST /api/transcribe
                    │                                    │ POST /api/summarize-bullets
                    └────────────────┬───────────────────┘
                                     │
                                     ▼
                    ┌────────────────────────────────────┐
                    │  Mobile app (Expo / React Native)  │
                    │  • Home (Search + Explore)         │
                    │  • Bookmarks, Downloads, Settings  │
                    └────────────────────────────────────┘
```

---

## 2. How the App Reads Data from the KB

### 2.1 Local SQLite (Primary Data Source)

All innovation content (stats, lists, filters, detail) is read from the local SQLite database via `src/database/db.js`. This module is the **single abstraction layer** for KB data:

| Function | Purpose |
|----------|---------|
| `getStats`, `getTopRegions`, `getChallengeCounts`, `getTypeCounts` | Home Explore dashboard |
| `searchInnovations`, `countInnovations` | Filtered browse / drilldown |
| `getRecentInnovations`, `getHelpInnovations` | Recent & help sections |
| `getInnovationById` | Detail view |
| `fullTextSearch` | Keyword search (exported but not used; AI search preferred) |
| `getAllCountries`, `getDataSources` | Filter panel options |

The DB schema includes `innovations`, `innovation_countries`, `innovation_types`, `innovation_sdgs`, `innovation_use_cases`, `innovation_prospective_users`, `data_sources`, and an FTS5 virtual table `innovations_fts` for full-text search. Auxiliary tables (`innovation_thumbs_up_counts`, `innovation_comments`, `innovation_bullet_cache`) store local-only user feedback and AI-generated summaries.

### 2.2 Remote Backend (AI-Enhanced Features)

The backend (`backend/server.js`) runs separately (port 3001) and uses a **copy** of the same `atiokb.db`. It serves:

- **AI search** — FTS candidate retrieval + LLM rerank for natural-language queries
- **Voice search** — Whisper transcription of recorded audio
- **Bullet summaries** — 3-bullet summaries for the DetailDrawer

The app calls these via `src/config/api.js` (`aiSearch`, `transcribeAudio`) and `SEARCH_API_URL` (derived from Metro host or simulator/emulator addresses).

---

## 3. Synchronization with ATIO KB Over Time

### 3.1 Current State: No Synchronization

There is **no automatic sync** with the ATIO KB. Data is fixed at build time:

- The bundled `atiokb.db` is a **point-in-time snapshot**.
- Updates to the ATIO website do **not** propagate to the app until a new DB is generated and a new app build is released.
- Thumbs up, comments, and bullet cache are stored **locally only** and never synced to a server.

### 3.2 Keeping Data Fresh (Current Model)

To refresh KB content:

1. Re-run the ETL/import process with updated JSON from the ATIO source.
2. Replace `assets/db/atiokb.db` with the new SQLite file.
3. Rebuild and redeploy the app (or ship an OTA update if using Expo Updates with asset changes).

### 3.3 Future: Real-Time Sync from ATIO KB API

When the ATIO KB API becomes available, the app can evolve to support real-time data:

- **Option A — API-first:** The app fetches innovations, filters, and detail from a remote API. Local SQLite becomes optional (e.g., for offline cache).
- **Option B — Hybrid:** API for fresh data when online; local SQLite as fallback when offline.
- **Option C — Background sync:** Periodic sync jobs pull delta updates from the API into local SQLite, keeping the existing `db.js` interface while refreshing content.

---

## 4. Readiness for Future API Connectivity

### 4.1 What Is Already in Place

| Capability | Status |
|------------|--------|
| Centralized API config | `src/config/api.js` — `SEARCH_API_URL`, `aiSearch`, `transcribeAudio` |
| Modular API calls | `aiSearch` and `transcribeAudio` are standalone; easy to extend |
| Single data abstraction | `db.js` is the sole reader of innovation data; screens depend on it, not on SQLite directly |
| Backend stateless design | Backend can be deployed separately and pointed at any DB or API |
| Stable schema | `innovations` and related tables have a consistent structure |

### 4.2 Gaps for Remote API

| Gap | Description |
|-----|-------------|
| **No configurable API base URL** | `SEARCH_API_URL` is derived from Metro host (localhost, 10.0.2.2, or device IP). There is no `EXPO_PUBLIC_API_URL` or similar for staging/production. |
| **No authentication** | No tokens, API keys, or headers for authenticated ATIO KB APIs. |
| **No offline/online handling** | No fallback when the backend is unreachable; no retry or cached responses for core data. |
| **Mixed data sources** | Explore uses local DB; Search uses backend. No unified abstraction that can switch between local and remote. |
| **User data not synced** | Bookmarks (AsyncStorage), downloads (AsyncStorage), thumbs up, and comments are device-only. |

### 4.3 Recommended Path to API Readiness

1. **Add `EXPO_PUBLIC_API_URL`** — Allow overriding the API base URL via environment variable for production.
2. **Introduce a data source abstraction** — Create a `DataService` (or similar) that implements the same interface as `db.js` but can fetch from an API. Use dependency injection or context to switch between local SQLite and remote API.
3. **Add auth support** — Extend `api.js` to attach auth headers (e.g., Bearer token) when `EXPO_PUBLIC_API_TOKEN` is set.
4. **Implement offline fallback** — When API calls fail, fall back to local SQLite if available.
5. **Optional: Background sync** — If using local SQLite as cache, add a sync job that periodically fetches updates from the API and merges into the local DB.

---

## 5. Summary

| Aspect | Current | Future (API) |
|--------|---------|--------------|
| **KB source** | JSON → SQLite snapshot, bundled in app | Real-time API (when available) |
| **Data flow** | Asset → copy → SQLite → `db.js` → screens | API → `DataService` → screens (with optional local cache) |
| **Sync** | None; static at build time | API-first or hybrid with background sync |
| **Backend** | Local copy of SQLite; AI search, transcription, bullets | Can proxy or replace with ATIO KB API |
| **API readiness** | Partial — modular API calls, centralized config; needs env-based URL, auth, and unified data layer | |

The app is **structurally prepared** for API connectivity: the data layer is centralized, API calls are modular, and the backend is decoupled. To fully support real-time ATIO KB data, the main work is adding a configurable API URL, authentication, a unified data abstraction that can switch between local and remote, and optional offline handling.
